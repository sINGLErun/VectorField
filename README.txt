Try to create a VectorField class for your FDTD work.
For example it can be Electrical or Magnetic field!

	24.07.2020, 22:05
	Образовалась хорошая задача: сделать интерьер восприимчивым к
	динамическому изменению ширины полей, пока моя голова от этого
	течёт, как и память.
	Есть идея: векторное поле всё ещё представляется в виде трёх
	скалярных; внутри скалярное поле строится на динамической
	основе. Реализация - выделениие памяти SIZE_X*SIZE_Y*SIZE_Z
	дальше работа с ним как с трёхмерным, используя индексацию:
		arr[i][j][k] == arr[i*SIZE_X + j*SIZE_Y + k];

	27.07.2020, 18:58
	Реализовано создание векторного поля с произвольными параметрами.
	Следующая задача - реализация стандартных операций с векторными
	полями, для этого, возможно, потребуется всё же отделить класс
	скалярного поля от векторного и сделать как раньше: векторное - 
	наследник скалярного.

	28.07.2020, 11:16
	Видимо, действительно, происходили утечки памяти по причине того,
	что оператор равенства не был определён. Поэтому указатель просто
	начинал смотреть на другую область памяти и то, на что он перестал
	указывать, порождало утечку. Сейчас я переделал всё на родительский
	класс, работает. Выделяется память для одного обьекта странно: под
	3х-мерное векторное поле почему то выделяется память четыре раза.
		Ответ: при создании класса-наследника автоматически вызыва-
		ется конструктор класса-родителя, который, в соответсвии с
		определением по умолчанию, выделяет память для массива.
		Решение: думаю, что стоит разделить всё-таки скалярное и
		векторное поле, после чего сделать подкласс компоненты, что-
		бы сделать и красиво и удобно

	28.07.2020, 12:51
	Задачи:
	+ Стоит сделать отдельный метод для инициализации, чтобы избежать
		дублирования кода;
	- Реализация стандартных операций;
	- Для проверки операций векторных полей стоит сделать считывание и
		запись полей в файл;
	- Проверка на границы, используя try, throw, catch.



